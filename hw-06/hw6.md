# Задание 1

*В Eshell выполните List comprehensions*

*Используя генераторы списков, создайте набор целых чисел от 1 до 10, которые делятся на три (например, [3,6,9]).*

```
20> [X || X <- lists:seq(1, 10), X rem 3 =:= 0].
[3,6,9]
```

*Используя генераторы списков, удалите все нецелые числа из списка. Возвращаться список целых чисел в квадрате: [1, “hello”, 100, boo, "boo", 9] должен возвращать [1, 10000, 81].*

```
20> [X * X || X <- [1, "hello", 100, boo, "boo", 9], is_integer(X)].
[1,10000,81]
```

# Задание 2

*Прокомментируйте код и возникшие ошибки:*

<<X:4, Y:2>> = <<42:6>>.

Записываем в Х - 4 бит, в Y - 2, все успешно сматчилось!

<<C:4, D:4>> = << 1998:6 >>.

```
23> <<C:4, D:4>> = <<1998:6>>.
** exception error: no match of right hand side value <<14:6>>
```
Пытаемся сопоставить левую часть, в которой данные распределены на два блока по 4 бит, когда в правой один равный шести, сопоставление с образцом не прошло.

<<C:4, D:2>> = << 1998:8 >>.

```
24> <<C:4, D:2>> = <<1998:8>>.
** exception error: no match of right hand side value <<"Î">>
```
Тут то же самое. Ожидаем, что в сумме будет 8, а слева 6.

# Задание 3

*Протестируйте функцию в Eshell с помощью данных:*

DataWrongFormat = <<4:4, 6:4, 0:8, 0:3>>.\
DataWrongVer = <<6:4, 6:4, 0:8, 232:16, 0:16, 0:3, 0:13, 0:8, 0:8, 0:16, 0:32, 0:32, 0:32, "hello">>.\
Data1 = <<4:4, 6:4, 0:8, 232:16, 0:16, 0:3, 0:13, 0:8, 0:8, 0:16, 0:32, 0:32, 0:32, "hello">>.\
Data2 = <<4:4, 6:4, 0:8, 100:16, 0:16, 0:3, 0:13, 0:8, 0:8, 0:16, 0:32, 0:32, 0:32, "world">>.\

```
2> DataWrongFormat = <<4:4, 6:4, 0:8, 0:3>>.
<<70,0,0:3>>
3> DataWrongVer = <<6:4, 6:4, 0:8, 232:16, 0:16, 0:3, 0:13, 0:8, 0:8, 0:16, 0:32, 0:32, 0:32, "hello" >>.
<<102,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,104,
  101,108,108,111>>
4> Data1 = <<4:4, 6:4, 0:8, 232:16, 0:16, 0:3, 0:13, 0:8, 0:8, 0:16, 0:32, 0:32, 0:32, "hello" >>.
<<70,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,104,
  101,108,108,111>>
5> Data2 = <<4:4, 6:4, 0:8, 100:16, 0:16, 0:3, 0:13, 0:8, 0:8, 0:16, 0:32, 0:32, 0:32, "world">>.
<<70,0,0,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,119,
  111,114,108,100>>
6> protocol:ipv4(DataWrongFormat).
** exception throw: {invalid_format}
     in function  protocol:ipv4/1 (protocol.erl, line 58)
7> protocol:ipv4(DataWrongVer).
** exception throw: {invalid_version}
     in function  protocol:ipv4/1 (protocol.erl, line 56)
8> protocol:ipv4(Data1).
Received data <<"hello">>
{ipv4,4,6,0,232,0,0,0,0,0,0,0,0,0,<<"hello">>}
9> protocol:ipv4(Data2).
Received data <<"world">>
{ipv4,4,6,0,100,0,0,0,0,0,0,0,0,0,<<"world">>}
```
*Обработайте в ipv4/1 случай когда данные не мачатся (не соответствуют ожидаемому формату) и вызовите exception (error, exit, throw) на ваш выбор - прокомментируйте ваш выбор.*

Вызвал exception с помощью throw, оно больше всего подходит, т.к. у нас не происходит чего-то необратимого и фатального, чтобы вызывать error или exit, а всего лишь вводятся не те данные, которые функция ожидает принять.


*Проверьте ваш pid (self/0).*\
*Вызовите предыдущую функцию protocol:ipv4(Data) в новом процессе (spawn/3) с DataWrongFormat или DataWrongVer.*\
*Проверьте ваш pid (self/0).*\
*Изменился ли он после того как предыдущая строка завершилась ошибкой? Почему?*
```
4> self().
<0.85.0>
5> spawn(protocol, ipv4, [Data1]).
<0.91.0>
Received data <<"hello">>
6> self().
<0.85.0>
7> spawn(protocol, ipv4, [DataWrongFormat]).
=ERROR REPORT==== 6-Nov-2023::23:48:41.407000 ===
Error in process <0.94.0> with exit value:
{{nocatch,{invalid_format}},
 [{protocol,ipv4,1,[{file,"protocol.erl"},{line,58}]}]}

<0.94.0>
8> self().
<0.85.0>
```
Pid процесса не изменился, потому что создание процесса не влияет на процесс, из которого он был запущен.

*Запустите функцию protocol:ipv4_listener/0 в новом процессе с помощью spawn/3 или spawn/1. Сохраните pid нового процесса в переменную ListenerPid.*

```
19> ListenerPid = spawn(protocol, ipv4_listener, []).
<0.110.0>
```
*Отправьте из Eshell сообщение ListenerPid с валидными данными Data1 или Data2.*

```
21> ListenerPid ! {ipv4, self(), Data1}.
Received data <<"hello">>
{ipv4,<0.85.0>,
      <<70,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,104,
        101,...>>}
```

*С помощью команды flush/0 проверьте, что вы получили ответ.*

```
23> flush().
Shell got {ipv4,4,6,0,232,0,0,0,0,0,0,0,0,0,<<"hello">>}
ok
```
*Попробуйте отправить данные которые не подходят по формату (ex. {ipv4, Data}, “Wrong args”, …)*

```
28> ListenerPid ! {ipv4, Data1}.
{ipv4,<<70,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,104,101,108,...>>}
29> flush().
ok
```